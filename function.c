//
//  function.c
//  AES_implementation
//
//  Created by 翔誉 on 2019/3/22.
//  Copyright © 2019 胡义臻. All rights reserved.
/*关键是实现AddRoundKey、SubBytes、ShiftRows和MixColumns四个模块，我们约定输入128bit长的秘钥并使用ECB模式，加密进行1+9+1轮，为此首先还要实现GenerateKey以及处理初始数据,各部分的设计见底部各函数旁的注释*/
#include <stdint.h>
#include <stdio.h>
#include "function.h"

const uint32_t rcon[10] = {//生成秘钥用；
    0x01000000UL, 0x02000000UL, 0x04000000UL, 0x08000000UL, 0x10000000UL,
    0x20000000UL, 0x40000000UL, 0x80000000UL, 0x1B000000UL, 0x36000000UL
};
const unsigned char S[256] = {//S盒替代
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
};

const unsigned char S_[256] = {//逆S盒
    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
};
const uint8_t Mix[4][4] = {{0x02, 0x03, 0x01, 0x01},//MixColumn用
    {0x01, 0x02, 0x03, 0x01},
    {0x01, 0x01, 0x02, 0x03},
    {0x03, 0x01, 0x01, 0x02}};
const uint8_t Mix_[4][4] = {{0x0E, 0x0B, 0x0D, 0x09},
    {0x09, 0x0E, 0x0B, 0x0D},
    {0x0D, 0x09, 0x0E, 0x0B},
    {0x0B, 0x0D, 0x09, 0x0E}};
uint32_t temp32=0;
uint8_t temp8[4]={0};

/*InitiateData*/
void InitiateData(uint8_t state[4][4], uint8_t *input)
{
    for(int i=0;i<4;i++)
        for(int j=0;j<4;j++)
            state[j][i]=*input++;
}
void RenturnInput(uint8_t state[4][4], uint8_t *input)
{
    for(int i=0;i<4;i++)
        for(int j=0;j<4;j++)
            *input++=state[j][i];
}
/*GenerateKey  输入一个16Bytesb秘钥，输出44Bytes的加密和解密秘钥*/
void GenerateKey(uint32_t *key,uint32_t *ek, uint32_t *dk)
{
    //需要的数据有rcon[i],操作有，逐字节循环左移和字节替换（4Bytes下替换）
    //4x4 Byte key and 4x4x11 Byte encodekey&decodekey
    for(int i=0;i<4;i++)
        ek[i]=*key++;
    for(int i=1;i<11;i++)
    {
        //这是一段代码，没有返回值的，必须单独拎出来用;宏里的括号很多，很容易写错；【考虑写一篇关于宏的博客】
        temp32=ek[4*i-1];//
        BITTOBYTE(temp32,temp8);
        temp8[i]=S[temp8[i]];
        BYTETOBIT(temp32,temp8);
        ROTLEFT(temp32,8);
        ek[4*i]=ek[4*(i-1)] ^temp32 ^rcon[i];
        ek[4*i+1]=ek[4*(i-1)+1]^ek[4*i];
        ek[4*i+2]=ek[4*(i-1)+2]^ek[4*i+1];
        ek[4*i+3]=ek[4*(i-1)+3]^ek[4*i+2];
    }
    for(int i=0;i<11;i++)
        for(int j=0;j<4;j++)//只要dk存在就会溢出
            dk[i*4+j]=ek[(10-i)*4+j];
}

/*AddRoundKey 输入state和子秘钥,解密过程也用这个*/
void AddRoundKey(uint8_t (*state)[4],const uint32_t *subkey)//必须传指针，不然赋值会x失效
{
    //需要的操作：32位拆成4Bytes和4Bytes拆成32bit；
    for(int i=0;i<4;i++){
    BITTOBYTE(*subkey,temp8);//key一直在0-3上循环，实际上想要在这里改变指针，必须要传一个指针的指针才可以
        subkey++;
        for(int j=0;j<4;j++)
            state[j][i]^=temp8[j];
    }
}



/*SubBytes 输入state*/
void SubBytes(uint8_t (*state)[4])
{
    //需要数据：S盒
    for (int i = 0; i < 4; ++i) {
        for (int j = 0; j < 4; ++j) {
            state[i][j] = S[state[i][j]];
        }
    }
}
void SubBytes_(uint8_t (*state)[4])//解密用
{
    //需要数据：S盒
    for (int i = 0; i < 4; ++i) {
        for (int j = 0; j < 4; ++j) {
            state[i][j] = S_[state[i][j]];
        }
    }
}


/*ShiftRows 输入state*/
void ShiftRows(uint8_t (*state)[4])
{
    uint32_t temp32=0;
    //需要操作：循环左移和循环右移（解密要右移）
    for (int i = 0; i < 4; ++i) {
            BYTETOBIT(temp32,state[i]);//处理第i行
     //       ROTLEFT(temp32,8*i);
        temp32=((temp32)<<(8*i)) | ((temp32)>>(32-(8*i)));
            BITTOBYTE(temp32, state[i]);//组装回去
    }
}
void ShiftRows_(uint8_t (*state)[4])
{
    uint32_t temp32;
    //需要操作：循环左移和循环右移（解密要右移）
    for (int i = 0; i < 4; ++i) {
        BYTETOBIT(temp32,state[i]);//处理第i行
        temp32=((temp32)>>(8*i)) | ((temp32)<<(32-(8*i)));
        BITTOBYTE(temp32, state[i]);//组装回去
    }
}

/*MixColumns 困难在于伽罗华域上乘法的实现*/
uint8_t GaloisMulti(uint8_t x,uint8_t y)
{
    uint8_t temp=0;
    for(int i=0;i<8;i++)
    {
        if(x & 0x01)//获取x当前最低位，是1就和y异或，即分配律下逐位相乘
            temp ^=y;
        int temp2=y & 0x80;
        y <<=1;//把本原多项式里的x^8先模掉
        if(temp2){//获取y当前最高位，是1就模一下本原多项式
            y ^=0x1B;//2^8的伽罗华域的本原多项式去除x^8后的二进制表示是0x1B
        }
        x >>=1;
    }
    return temp;
}

void MixColumn(uint8_t (*state)[4])
{
    //需要的数据：置换矩阵
    uint8_t temp8[4][4];
    for (int i = 0; i < 4; ++i) {
        for (int j = 0; j < 4; ++j){
            temp8[i][j] = state[i][j];
        }
    }
    for (int i = 0; i < 4; ++i) {
        for (int j = 0; j < 4; ++j) {  //伽罗华域加法和乘法
            state[i][j] = GaloisMulti(Mix[i][0], temp8[0][j]) ^ GaloisMulti(Mix[i][1], temp8[1][j])
            ^ GaloisMulti(Mix[i][2], temp8[2][j]) ^ GaloisMulti(Mix[i][3], temp8[3][j]);
        }
    }
}
void MixColumn_(uint8_t (*state)[4])
{
    //需要的数据：置换矩阵
    uint8_t temp8[4][4];
    for (int i = 0; i < 4; ++i) {
        for (int j = 0; j < 4; ++j){
            temp8[i][j] = state[i][j];
        }
    }
    for (int i = 0; i < 4; ++i) {
        for (int j = 0; j < 4; ++j) {
            state[i][j] = GaloisMulti(Mix_[i][0], temp8[0][j]) ^ GaloisMulti(Mix_[i][1], temp8[1][j])
            ^ GaloisMulti(Mix_[i][2], temp8[2][j]) ^ GaloisMulti(Mix_[i][3], temp8[3][j]);
        }
    }
}
